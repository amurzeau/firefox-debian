From: Lee Salzman <lsalzman@mozilla.com>
Date: Mon, 29 Mar 2021 20:35:12 +0000
Subject: Bug 1700520 - Use PREFER_INLINE on large SWGL functions. r=jrmuizel

It seems like blend_pixels is the major offender in terms of slowing down GCC
compile times, so lets annotate such functions with PREFER_INLINE. Then, we ensure
that PREFER_INLINE disables always_inline for either GCC or debug builds so that
in cases where we know the compiler is sensitive to binary bloat, we aren't forcing
inlining.

Differential Revision: https://phabricator.services.mozilla.com/D109789
---
 gfx/wr/swgl/src/blend.h |  4 ++--
 gfx/wr/swgl/src/gl.cc   | 16 +++++++++++++++-
 2 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/gfx/wr/swgl/src/blend.h b/gfx/wr/swgl/src/blend.h
index 8a1a6e7..524323e 100644
--- a/gfx/wr/swgl/src/blend.h
+++ b/gfx/wr/swgl/src/blend.h
@@ -405,7 +405,7 @@ static ALWAYS_INLINE void restore_aa() {
   blend_key = BlendKey(AA_BLEND_KEY_NONE + blend_key);
 }
 
-static ALWAYS_INLINE WideRGBA8 blend_pixels(uint32_t* buf, PackedRGBA8 pdst,
+static PREFER_INLINE WideRGBA8 blend_pixels(uint32_t* buf, PackedRGBA8 pdst,
                                             WideRGBA8 src, int span = 4) {
   WideRGBA8 dst = unpack(pdst);
   const WideRGBA8 RGB_MASK = {0xFFFF, 0xFFFF, 0xFFFF, 0,      0xFFFF, 0xFFFF,
@@ -686,7 +686,7 @@ static ALWAYS_INLINE WideRGBA8 blend_pixels(uint32_t* buf, PackedRGBA8 pdst,
   // clang-format on
 }
 
-static ALWAYS_INLINE WideR8 blend_pixels(uint8_t* buf, WideR8 dst, WideR8 src,
+static PREFER_INLINE WideR8 blend_pixels(uint8_t* buf, WideR8 dst, WideR8 src,
                                          int span = 4) {
 // clang-format off
 #define BLEND_CASE_KEY(key)                          \
diff --git a/gfx/wr/swgl/src/gl.cc b/gfx/wr/swgl/src/gl.cc
index d495d4c..8083846 100644
--- a/gfx/wr/swgl/src/gl.cc
+++ b/gfx/wr/swgl/src/gl.cc
@@ -58,10 +58,24 @@ WINBASEAPI BOOL WINAPI QueryPerformanceFrequency(LARGE_INTEGER* lpFrequency);
 }
 
 #else
-#  define ALWAYS_INLINE __attribute__((always_inline)) inline
+// GCC is slower when dealing with always_inline, especially in debug builds.
+// When using Clang, use always_inline more aggressively.
+#  if defined(__clang__) || defined(NDEBUG)
+#    define ALWAYS_INLINE __attribute__((always_inline)) inline
+#  else
+#    define ALWAYS_INLINE inline
+#  endif
 #  define NO_INLINE __attribute__((noinline))
 #endif
 
+// Some functions may cause excessive binary bloat if inlined in debug or with
+// GCC builds, so use PREFER_INLINE on these instead of ALWAYS_INLINE.
+#if defined(__clang__) && defined(NDEBUG)
+#  define PREFER_INLINE ALWAYS_INLINE
+#else
+#  define PREFER_INLINE inline
+#endif
+
 #define UNREACHABLE __builtin_unreachable()
 
 #define UNUSED [[maybe_unused]]
